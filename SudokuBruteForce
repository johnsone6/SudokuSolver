public class SudokuBruteForce {
	private int[][] board, newBoard;
	private int width, length, boardSize;
	
	
	
	public SudokuBruteForce(int width, int length, int[][] board){
		this.width = width;
		this.length = length;
		this.board = board;
		this.boardSize = width * length;
	}
	
	
	
	public int[][] findSolution(){
		//Placeholder
		return new int[1][1];
	}
	
	
	/**
	 * Checks to see if the board is a solution
	 * @param board the puzzle to be checked
	 * @return whether or not the current configuration of the board is a solution to the puzzle
	 */
	private boolean checkBoard(int[][] board){
		//Placeholder
		return true;
	}
	
	
	//Void is a placeholder until I figure out what data type to return
	private void findBlanks(){
		
	}
	/** 
	* finds sum of one row then calculates the
	* sum of the entire board
	**/
	public int calcSumInt(int boardSize){
		int bs = boardSize;
		int sumRowInt;
		int sumInt;
		sumRowInt = (((bs*bs) + bs)/2);
		sumInt = sumRowInt * bs;
		return sumInt;
	}
	
	/** 
	 * sums actual values of puzzle, compares to 
	 * the puzzles magic integer, then returns
	 * it's validity
	 **/
	public boolean checkPuzzleSum(int[][] board, int magicInt) {
		boolean sumValid = false;
		int sum = 0;
		int[][] b = board;
		int mi = magicInt;
		
		for(int i = 0; i < b.length; i++){
            for(int j = 0; j < b[i].length; j++){
                sum = sum + b[i][j];
            }
        }
		
		System.out.println("Sum of puzzle: " + sum);
		
		if(sum == mi){
			sumValid = true;
			return sumValid;
		}
		else 
			return sumValid;
	}
	
	/**
	 * Checks the inner boxes for duplicate items
	 * @return true if the board contains no duplicate items, false if the board contains duplicates
	 */
	public boolean checkBox(){
		
		boolean[] numbers; 

		for (int boxX = 0; boxX < boardSize; boxX += length){
			for (int boxY = 0; boxY < boardSize; boxY += width){
				//This is initialized to the default of all false
				numbers = new boolean[boardSize];
				
				for (int x = boxX; x < length + boxX; x++){
					for (int y = boxY; y < width + boxY; y++){
						
						//System.out.print(board[x][y]);
						
						//rather than checking the numbers themselves, I am using an array in a pseudo sorted manner
						//If a number is already contained in the "box" (array) it's spot will be set to true, and I can check
						//that spot. Otherwise, add it to the known numbers (ie: set it's index to true)
						
						if (numbers[board[x][y] - 1]){
							return false;
						}
						else{
							numbers[board[x][y] - 1] = true;
						}
					}
					//System.out.println();
				}
				//System.out.println();
			}
		}

		return true;
	}
	
	
}
